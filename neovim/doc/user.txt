*user.txt* General help for all installed plugins.

==============================================================================
CONTENTS                                                         *user.contents*

1. `Navigation`                                    |user.navigation|
  1.1 In-File Navigation                         |user.in_file_navigation|
    1.1a Vertical Movement                       |user.vertical_movement|
    1.1b Horizontal Movement                     |user.horizontal_movement|
    1.1c In-File Searching                       |user.in_file_searching|
  1.2 Out-of-File Navigation                     |user.out_file_navigation|
    1.2a Windows                                 |user.windows|
    1.2b Buffers                                 |user.buffers|
    1.2c Tabs                                    |user.tabs|
  1.3 File Navigation                            |user.file_navigation|
    1.3a Telescope                               |user.telescope_file|
    1.3b Grapple                                 |user.grapple|
    1.3c Oil                                     |user.oil|
  1.4 Special Navigation                         |user.special_navigation|
    1.4a Suspending                              |user.suspending|

2. `Editing`                                       |user.editing|

4. `Searching`                                     |user.searching|
  4.1 Telescope                                  |user.telescope|
  4.2 Quickfix List                              |user.quickfix|
  4.3 LSP Searching                              |user.lsp_search|

5. `LSP`                                           |user.lsp|
  5.1 Specific LSPs                              |user.lsps|
    5.1a clangd                                  |user.clangd|
    5.1b gdscript                                |user.gdscript|

==============================================================================
1. Navigation                                                  *user.navigation*

Navigation in NeoVim is generally done using the `h`, `j`, `k`, & `l` keys for
cardinal directions. Navigations which does not use this can sometimes use `u`
and `d` to indicate '[u]p' and '[d]own', `g` to for '[g]o', `f` for '[f]ind', or
some non-generic atomic operation.

Most navigation in this configuration follows this standard, although
there are some exceptions.

------------------------------------------------------------------------------
1.1 In-File Navigation                                 *user.in_file_navigation*

In-file nagivation can be split into three parts: vertical (get to the
line), horizontal (get to the character), and search (get somewhere).

`|======================|`
 `1.1a Vertical Movement`                                 *user.vertical_movement*

Vertical movement is relatively simple, mainly consisting of chaining
fixed-size jumps.

`k` and `j` take you up an down a line, `<C-u>` and `<C-d>` do the same but
for a half-page. `gg` and `G` take you to the top and bottom lines of the
file, `H` and `L` do the same for your screen.

Prepending a number before `k` or `j` jumps you that many lines in the
direction. This can be combined with relative line numbers to make the
required number visible.

An effective strategy for vertical movement is using `<C-u>` & `<C-d>` to
scroll around and finishing with a specific length relative jump with
`[count]k` or `[count]j`.

If you know the specific line numbers, `[count]G`, `[count]gg`, or
`:[count]` will all take you to a line number.

`[count]%` will take you to the line that percent down the file.

`(` or `)`, and `{` or `}` will take you forward/backward through sentences
and paragraphs respectively.

`|========================|`
 `1.1b Horizontal Movement`                             *user.horizontal_movement*

Horizontal movement is significantly more complex. Effective horizontal
movement involves quick jumps to identified landmarks (e.g. a letter,
brackets, the start of the line).

`h` and `l` take you backwards and forwards on a line. These can be prefixed
with [count] but counting characters is hard.

There are quite a few keys which take you to the start or end of a line in
different flavors, these are all useful to some extent:
- `0` takes you to the first character on a line.
- `$` takes you to the last one (this persists when going up/down).
- `^` takes you to the first non-blank character.
  - `_` does the same thing but also takes you [count] - 1 down (this is
  generally indistinguishable from `^`).
  - `-` and `+` do the same thing but take you [count] lines up or down.
- `g_` takes you the the last non-blank character and [count] (this is not
  very useful as you don't see this often and it doesn't persist like `$`).
- Prefixing one of the non-up/down keys with `g` (`g0`, `g$`, or `g^`) does
  the same thing but on the screen line. `g<END>` acts like the `g_` equivalent
  of `g^` but it's not very useful and I don't have the key on my keyboard.

The main meat of horizontal movement is in find operators. These take you to
instances of characters, relative to the cursor, in the current line:
- `f{char}` takes you to the next instance of {char} to the right.
- `F{char}` takes you to the next instance of {char} to the left.
- `t{char}` takes you to the character before the next instance to the right.
- `T{char}` takes you to the character before the next instance to the left.
- All of these operators can be prepended with [count] to go to the [count]th
  {char}.
- `;` repeats the last find operator [count] times.
- `,` repeats the last find operator [count] times in the other direction.

Another method for horizontal movement is using word operators. These act on
words (contiguous letters, digits, or underscores or contiguous other
characters, separated by whitespace) or WORDS (contiguous characters separated
by whitespace).
- `w` takes you forward [count] words, to the start of a word.
- `W` takes you forward [count] WORDS, to the start of a word.
- `b` takes you backward [count] words, to the start of a word.
- `B` takes you backward [count] WORDS, to the start of a word.
- `e` takes you forward [count] words, to the end of a word.
- `E` takes you forward [count] WORDS, to the end of a word.
- `ge` takes you backward [count] words, to the end of a word.
- `gE` takes you backward [count] WORDS, to the end of a word.

`|=======================|`
 `1.1c  In-File Searching`                                *user.in_file_searching*

The final form of navigation in files is searching. This involves finding or
jumping to the positions of known or semi-known landmarks (e.g. a function
name, a print statement you think exists).

Searching is largely done with the `/` and `?` characters, searching forwards and
backwards respectively.
- `/{pattern}<CR>` (and the equivalent for `?`) searches
  forward to the [count]th occurrence of {pattern}. This kind of search
  ignores case unless {pattern} contains upper case characters.
- `/{pattern}/{offset}<CR>` (and the equivalent for `?`) searches forward to
  the [count]th occurrence on {pattern} with an offset of {offset}.
- `n` repeats the last usage of `/` or `?` [count] times.
- `N` repeats the last usage of `/` or `?` [count] times in the opposite direction.
- `/<CR>` and `?<CR>` search forward and backward using the last used pattern and
  offset.
- `//{offset}<CR>` and `??{offset}<CR>` search forward and backward using the
  last used pattern and a new {offset}.
- `*` and `#` search forward and backward to the [count]th occurrence of the
  word nearest to the cursor. These ignore case when searching and search for
  whole words and not substrings.
- `g*` and `g#` act similarly to their non-prefixed counterparts but accept
  substrings.

Offsets modify the final cursor position relative to the match, the following
are valid:
- [num] or +[num] offset [num] lines downward, in column 1.
- -[num] offsets [num] lines upward, in column 1.
- e[+num] and e[-num] offset [num] characters to the right and left of the end
  of the match.
- s[+num] and s[-num] offset [num] characters to the right and left of the
  start of the match.
  - b[+num] and b[-num] are equivalent.
- ;/{pattern} and ;?{pattern} perform another search.

Patterns are much more complex.

TODO: FINISH

------------------------------------------------------------------------------
1.2 Out-of-File Navigation                            *user.out_file_navigation*

NeoVim organises files with three main constructs: buffers, windows, and tabs.
- Buffers are in-memory representation of text, usually a file.
- Windows are viewports which display buffers.
- Tab pages are collections of windows.

Organising your workspace with these allows you to more easily view files,
along with better organising and isolating them.

`|============|`
 `1.2a Windows`                                                     *user.windows*

Interacting with windows is done with keybinds starting with `<C-w>`, or `:`
commands. `:[count]winc[md] {arg}` is equivalent to `[count]<C-w>{arg}`.

Windows are generally created by splitting others either horizontally or
vertically. Splitting creates a new window next to the current one, resizing
the current window to accommodate.
- `<C-w>s` or `:[N]sp[lit] [file]` splits the window horizontally.
- `<C-w>v` or `:[N]vs[plit] [file]` splits the window vertically.
- When creating splits, [count] or N determines the size of the new window,
  and [file] optionally opens a file in the new window.
- Splits can also be created with an empty file using `<C-w>n` or `:[N]new`
  for horizontal splits and `:[N]vne[w]` for a vertical split.
- `:[N]sv[iew] [file]` creates a readonly horizontal split.
- `<C-w>^` creates a horizontal split with the alternate file. `:sp #` is
  largely equivalent but can be executed vertically (`:vs #`).

Commands that create splits can be modified by chaining the following
commands into them:
- `:hor[izontal] {cmd}` and `:vert[ical] {cmd}` make {cmd} split vertically
  or horizontally.
  - These can also be used to modify `:te[rminal]` and `:che[ckhealth]` to make
    them create splits.
- `:lefta[bove] {cmd}` or `:abo[veleft] {cmd}`, and `:rightb[elow] {cmd}` or
  `:bel[owright] {cmd}` make {cmd} split above/left and below/right based on
  whether it would have split horizontally/vertically.
- `:to[pleft] {cmd}` and `:bo[tright] {cmd}` make {cmd} create a
  horizontal/vertical split on the top/left and bottom/right of the editor,
  taking up the full width/height.
- These commands can be chained, for example `:vert lefta sv [file]` creates a
  vertical split to the left of the current window with a readonly buffer in
  it.

Behavior when closing windows is dependent on the option 'hidden'. When
'hidden' is unset, closing the last window for a buffer will remove the
buffer. When 'hidden' is set, closing the window will not remove the buffer,
hiding it instead.

Windows can be closed in multiple ways:
- `<C-w>q` or `:[count]q[uit][!]` closes the current window, exiting vim if it was
  the last non-help/preview window. Will not close the last window (or the
  last window for a buffer with 'hidden' unset) if it has changes, ! overrides
  this, discarding changes.
- `<C-w>c` or `:[count]clo[se][!]` closes the current window. Will not close the
  last window, and will not close the last window for a buffer if it has
  changes and 'hidden' is unset. ! makes the command act as if 'hidden' was
  set.
- `:[count]hid[e]` closes the current window, acting as if 'hidden' was set.
- `:hid[e] {cmd}` executes {cmd} as if 'hidden' was set.
- `<C-w>o` or `:[count]on[ly][!]` makes the current window the only one on screen,
  closing all others. If 'hidden' is unset, doesn't close windows with
  changes. ! overrides this, making them hidden.
- `[count]fc[lose][!]` closes the [count] highest floating windows. ! closes all
  floating windows.
- For window closing commands, [count] optionally defines the window to close:
  - A number closes that window, with 1 being the first.
  - $ closes the last window.
  - +N and -N close the Nth next and Nth previous windows.

Moving between windows can be done in the following ways:
- `<C-w>h/j/k/l` or `<C-h/j/k/l>` (user mappings) move the cursor between
  windows like the `h`, `j`, `k`, and `l` keys. Prefixing them with [count]
  moves [count] windows in that direction.
- `<C-w>w` moves the custor to the next |focusable| window to below/to the
  right of the current one (with that priority), if there is none, loops to
  the top-left window. `<C-w>W` goes in the opposite direction. Prefixing with
  [count] makes both go the the [count]th window in the cycle.
- `<C-w>t` and `<C-w>b` move the cursor to the top-left and bottom-right
  windows respectively.
- `<C-w>p` moves the cursor to the last accessed window (similar to `<C-6>`).

Windows can be rearranged in the following ways:
- `<C-w>r` rotates windows downwards/rightwards on their row/column, looping the
  start/end. `<C-w>R` rotates in the opposite direction. Rotates within the
  row/column the current window is in and will not rotate if another
  perpendicular split exists in the row/column.
- `<C-w>x` switches the current window with the next, placing the cursor in
  the other. Switching is only done in the row/column of the current window.
  Prefixing with [count] switches with the [count]th window.
- `<C-w>H/J/K/L` move the current window to the left/bottom/top/right of the
  screen, taking up the full width/height.
- The row/column a window is in is determined by the last type of split
  applied to it.

Windows can be resized in the following ways:
- `<C-w>+/-` or `:res[ize] +/-N` resize the current window vertically, with +
  increasing the height and - decreasing it.
- `<C-w>>/<` or `:vert[ical] res[ize] +/-N` resize the current window
  horizontally, with >/+ increasing the width and </- decreasing it.
- `<C-Up/Down/Left/Right>` (user mappings) can be used in place of the previous
  mappings to resize windows, resizing by 2 * [count].
- `<C-w>_` or `:res[ize] [N]` resize the current window to a specific height
  based on [count]/[N], defaulting to the maximum possible.
- `<C-w>|` or `:vert[ical] res[ize] [N]` resize the current window to a
  specific width based on [count]/[N], defaulting to the maximum possible.
- `z{N}<CR>` resizes the current window to height {N}.
- `:res[ize]` can be prefixed with [count], similarly to window closing
  commands, to resize a specific window.
- `<C-w>=` resizes all windows to be equally large.
  - If executed as `:winc[md] =`, it can be prefixed with `:hor[izontal]` or
    `:vert[ical]` to only equalize on that axis.

`|============|`
 `1.2b Buffers`                                                     *user.buffers*



`|=========|`
 `1.2c Tabs`                                                           *user.tabs*


